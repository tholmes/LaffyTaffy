/*
 * Copyright Utah State University Research Foundation.
 * All rights reserved except as specified below.
 * This information is protected by a Non-Disclosure/Government Purpose
 * License Agreement and is authorized only for United States Federal
 * Government use.
 * This information may be subject to export control.
 */
"use strict";
const fs = require("fs");
const crypto = require("crypto");
const _ = require("lodash");
const serverConfig = require("./serverConfig");
const logger = require("./logger");
const cryptoKeyFile = serverConfig.get("web:cryptoKey");
const symmetricAlgorithm = serverConfig.get("web:encryption:symmetric");
const hashKeyLength = serverConfig.get("web:encryption:hashKeyLength");
const hashSaltLength = serverConfig.get("web:encryption:hashSaltLength");
const hashIterations = serverConfig.get("web:encryption:hashIterations");
const encoding = serverConfig.get("web:encryption:encoding");
const modExName = serverConfig.get("web:encryption:keyGen");
// TODO: document the following.
// algorithm default = aes-256-ctr
// http://lollyrock.com/articles/nodejs-encryption/
// http://web.cs.ucdavis.edu/~rogaway/papers/modes.pdf
// modExName default = modp5
// modular exponential groups 1,2,5 http://www.rfc-editor.org/rfc/rfc2412.txt
// modular exponential groups 14,15,16,17,18 http://www.rfc-editor.org/rfc/rfc3526.txt

var key;
if (fs.existsSync(cryptoKeyFile)) {
  key = fs.readFileSync(cryptoKeyFile, { encoding: encoding });
} else {
  var diffie = crypto.getDiffieHellman(modExName);
  diffie.generateKeys(encoding);
  key = diffie.getPublicKey(encoding);
  fs.writeFile(cryptoKeyFile, key, function (err) {
    if (err) {
      logger.error("[CRYPTO] Failed to write encryption key: " + err.stack);
    }
  });
}

function saltedHash(plainText, salt, cb) {
  crypto.pbkdf2(plainText, salt, hashIterations, hashKeyLength, "SHA1", function (err, hashedText) {
    cb(err, hashedText.toString(encoding), salt.toString(encoding));
  });
}

exports.encrypt = function (plainText) {
  var cipher = crypto.createCipher(symmetricAlgorithm, key);
  var cipherText = cipher.update(plainText, "utf8", encoding);
  cipherText += cipher.final(encoding);
  return cipherText;
};

exports.decrypt = function (encryptedText) {
  var decipher = crypto.createDecipher(symmetricAlgorithm, key);
  var plainText = decipher.update(encryptedText, encoding, "utf8");
  plainText += decipher.final("utf8");
  return plainText;
};

exports.hash = function (plainText, cbOrSalt, cb) {
  if (_.isFunction(cbOrSalt)) {
    crypto.randomBytes(hashSaltLength, function (err, salt) {
      if (err) {
        cbOrSalt(err);
        return;
      }
      saltedHash(plainText, salt, cbOrSalt);
    });
  } else {
    saltedHash(plainText, new Buffer(cbOrSalt, encoding), cb);
  }
};
